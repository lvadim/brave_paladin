<documents>
<document index="1">
<source>.\main.py</source>
<document_content>
import pygame
from scripts import game_manager
from scripts import input_manager
    
def main():
    pygame.init()
    pygame.display.set_caption("Brave Paladin")
    clock = pygame.time.Clock()
    game = game_manager.Game()
    input_manager.InputManager.AddKeyDownListener(game)

    while not input_manager.InputManager.isNeedExit:
        input_manager.InputManager.processEvents()
        game.runLogic()
        game.draw()
        clock.tick(60)
        
    pygame.quit()
    
main()

</document_content>
</document>
<document index="2">
<source>.\scripts\actor.py</source>
<document_content>
import pygame
from scripts import animated_sprite

class Actor:
	def __init__(self, logic, data_provider, uid):
		self.sprite = animated_sprite.AnimatedSprite(self.onAnimationComplete)
		self.logic = logic
		self.logic.assignView(self.sprite)
		self.data_provider = data_provider
		self.uid = uid

	def draw(self):
		x, y = self.getSpriteActualPosition()
		self.sprite.SetPosition(x, y)
		self.sprite.Draw()
		
	def update(self):
		self.logic.Update()
		self.sprite.Update()

	def onAnimationComplete(self, name):
		self.logic.onAnimationComplete(name)

	def getSpriteActualPosition(self):
		w, h = self.sprite.GetSize()
		x, y = self.logic.GetPosition()
		mx, my = self.data_provider.getMapPosition()
		return(mx + x - w / 2, my + y - h)

	def getY(self):
		return self.logic.pos_y

	def isRightDierction(self):
		return not self.sprite.need_flip

	def getPosition(self):
		return (self.logic.pos_x, self.logic.pos_y)
		
	def getAttackDist(self):
		return self.logic.attackDist

	def onDamage(self, damage_count):
		self.logic.onDamage(damage_count)
</document_content>
</document>
<document index="3">
<source>.\scripts\animated_sprite.py</source>
<document_content>
import pygame
from scripts import game_screen

class AnimatedSprite(pygame.sprite.Sprite):
    def __init__(self, animation_complete_callback = None):
        pygame.sprite.Sprite.__init__(self)

        self.animation = None
        self.onAnimationComplete = animation_complete_callback
        
        self.running = True
        self.runningFrame = 0
        self.runningTime = pygame.time.get_ticks()
        self.need_flip = False

    def nextFrame(self):
        if self.runningFrame == len(self.animation.sprites) - 1:
            self.runningFrame = 0
            if (self.onAnimationComplete):
                self.onAnimationComplete(self.animation.name)
        else:
            self.runningFrame += 1

    def prevFrame(self):
   		if self.runningFrame == 0:
   			self.runningFrame = len(self.animation.sprites) - 1
   		else:
   			self.runningFrame -= 1

    def stopPlay(self):
   		self.running = not self.running
        
    def Update(self):
        if not self.animation: return

        self.image = self.animation.sprites[self.runningFrame]
    
        if self.running:
            if pygame.time.get_ticks() - self.runningTime > self.animation.speed:
                self.runningTime = pygame.time.get_ticks()
                self.nextFrame()

    def Draw(self):
        if not self.animation: return
        if (self.need_flip):
            game_screen.Screen.screen.blit(pygame.transform.flip(self.image, True, False), self.rect)
        else:
            game_screen.Screen.screen.blit(self.image, self.rect)

    def SetAnimation(self, animation):
        self.runningFrame = 0
        self.animation = animation
        self.image = self.animation.sprites[0]
        self.rect = self.image.get_rect()

    def SetPosition(self, x, y):
        if not self.animation: return
        self.rect.x = x
        self.rect.y = y

    def SetFlip(self, flip_value):
        self.need_flip = flip_value

    def GetSize(self):
        if self.animation:
            return (self.animation.width, self.animation.height)
        else:
            return (0, 0)

    def setLastFrame(self):
        self.runningFrame = len(self.animation.sprites) - 1

        
</document_content>
</document>
<document index="4">
<source>.\scripts\animation.py</source>
<document_content>
import json

class AnimationData:
    def __init__(self, filename):
        self.load(filename)

    def load(self, filename):
        f = open(filename)
        data = json.load(f)
        self.width = data['width']
        self.height = data['height']
        self.image_file = data['image_file']
        self.animation_speed = data['animation_speed']
        self.frames = data['frames']
        self.name = data['name']

class Animation:
    def __init__(self, sprites, animatiom_data):
        self.sprites = sprites
        self.speed = animatiom_data.animation_speed
        self.width = animatiom_data.width
        self.height = animatiom_data.height
        self.name = animatiom_data.name
</document_content>
</document>
<document index="5">
<source>.\scripts\game_manager.py</source>
<document_content>
import pygame
from scripts import level_view
from scripts import level_generator
from pygame.locals import *
from scripts import resource_manager
from scripts import actor
from scripts import player_controller
from scripts import game_screen
from scripts import input_manager
from scripts import skeleton_logic
from scripts import zombie_logic
from scripts import my_utils
from scripts import game_ui
from enum import Enum
from scripts import monster_behaviour

#Background color
BACKGROUND = (20, 20, 20)

class EEnemyType(Enum):
    SKELETON = 0
    ZOMBIE = 1

class Game(object):

    unique_actor_id = 0

    def getNextActorId():
        Game.unique_actor_id += 1
        return Game.unique_actor_id

    def __init__(self):
        lvl_gen = level_generator.LevelGenerator()
        self.lvl_view = level_view.LevelView("data/dungeon.json") #lvl_gen)
        #self.lvl_view.SetPosition(100, 100)

        #--- align view with player position
        screen_center = game_screen.Screen.getScreenCenter()
        player_pos = self.getPlayerInitialPos()
        delta = (screen_center[0] - player_pos[0], screen_center[1] - player_pos[1])
        self.lvl_view.SetPosition(*delta)
        
        self.actors = dict()

        #--- player
        self.player_ctrl = player_controller.PlayerController(self, 0)
        input_manager.InputManager.AddKeyDownListener(self.player_ctrl)
        input_manager.InputManager.AddKeyUpListener(self.player_ctrl)
        self.player_actor = actor.Actor(self.player_ctrl, self, 0)
        self.actors[self.player_actor.uid] = self.player_actor

        self.ui = game_ui.GameUI()

        #--- add enemies
        self.addEnemy(EEnemyType.SKELETON, 17, 5)
        self.addEnemy(EEnemyType.SKELETON, 11, 19)
        self.addEnemy(EEnemyType.SKELETON, 9, 19)
        self.addEnemy(EEnemyType.SKELETON, 22, 26)

        self.addEnemy(EEnemyType.ZOMBIE, 20, 8)
        self.addEnemy(EEnemyType.ZOMBIE, 26, 30)
        self.addEnemy(EEnemyType.ZOMBIE, 26, 29)
        self.addEnemy(EEnemyType.ZOMBIE, 29, 30)

        self.overlay = pygame.image.load("images/overlay.png")

        
    def runLogic(self):
        # --- list() - for make copy and prevent "RuntimeError: dictionary changed size during iteration"
        for key, val in list(self.actors.items()):
            val.update()
    
    def draw(self):
        game_screen.Screen.screen.fill(BACKGROUND)

        self.lvl_view.draw()

        sorted_values = sorted(self.actors.items(), key=lambda index : index[1].getY())
        for key, value in sorted_values:
            value.draw()

        game_screen.Screen.screen.blit(self.overlay, [0, 0])

        self.ui.draw(health_coef = self.player_ctrl.health / self.player_ctrl.max_health, player_pos = self.lvl_view.getCellByCoord(*self.player_actor.getPosition()))

        pygame.display.update()

    def onKeyDown(self, ley_id):
        if ley_id == K_l:
            #self.lvl_view.SetPosition(200, 200)
            #self.lvl_view.SetPosition(360, 240)
            self.lvl_view.reloadMap("data/dungeon.json")
        elif ley_id == K_z:
            self.addEnemy()
        elif ley_id == K_x:
            print ("---> actors:", len(self.actors))

    def addEnemyRandomly(self):
        x, y = self.lvl_view.getRandomPassableCoord()
        new_uid = Game.getNextActorId()
        enemy_logic = zombie_logic.ZombieLogic(self, x, y, new_uid)
        enemy_actor = actor.Actor(enemy_logic, self, new_uid)
        self.actors[enemy_actor.uid] = enemy_actor

    def addEnemy(self, enemy_type, x, y):
        new_uid = Game.getNextActorId()
        coord_x, coord_y = self.lvl_view.getCellCoordinates(x, y)
        enemy_logic = None
        
        if enemy_type == EEnemyType.SKELETON:
            enemy_logic = skeleton_logic.SkeletonLogic(self, coord_x, coord_y, new_uid)
        elif enemy_type == EEnemyType.ZOMBIE:
            enemy_logic = zombie_logic.ZombieLogic(self, coord_x, coord_y, new_uid)
        
        enemy_actor = actor.Actor(enemy_logic, self, new_uid)

        self.actors[enemy_actor.uid] = enemy_actor

    # --- data provider methods ---------------------
    def getMapPosition(self):
        return self.lvl_view.GetPosition()

    def getPlayerInitialPos(self):
        #tx, ty = self.lvl_view.getTileSize()
        player_cell_x = 2
        player_cell_y = 2
        return self.lvl_view.getCellCoordinates(player_cell_x, player_cell_y)
        #return (player_cell_x * tx + tx / 2, player_cell_y * ty + ty / 2)

    def canMoveHere(self, x, y, object_width, object_height):
        check1 = self.lvl_view.isPassable(x, y)
        check2 = self.lvl_view.isPassable(x - object_width / 2, y)
        check3 = self.lvl_view.isPassable(x + object_width / 2, y)
        check4 = self.lvl_view.isPassable(x, y - object_height)
        return check1 and check2 and check3 and check4

    def onAttack(self, attecker_actor_id, damage_count):
        if attecker_actor_id in self.actors:
            attacker = self.actors[attecker_actor_id]
            if attacker.uid == 0: # --- player attacks monster
                for key, value in self.actors.items():
                    dist = my_utils.distBetweenActors(attacker, value)
                    if value.uid != 0 and my_utils.isActor1LookAtActor2(attacker, value) and dist <= attacker.getAttackDist():
                        value.onDamage(damage_count)
                        break
            else: # --- monster attacks player
                dist = my_utils.distBetweenActors(attacker, self.player_actor)
                if my_utils.isActor1LookAtActor2(attacker, self.player_actor) and dist <= attacker.getAttackDist():
                    self.player_actor.onDamage(damage_count)

    def onDie(self, actor_id):
        if actor_id in self.actors:
            self.actors.pop(actor_id)

    def getPlayerPosition(self):
        return self.player_actor.getPosition()

    def getRandomPassablePoint(self):
        return self.lvl_view.getRandomPassableCoord()

    def onPlayerMove(self, dx, dy):
        self.lvl_view.move(-dx, -dy)
                
</document_content>
</document>
<document index="6">
<source>.\scripts\game_screen.py</source>
<document_content>
import pygame

SCREEN_WIDTH = 720
SCREEN_HEIGHT = 480

class Screen:
	screen = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])

	def getScreenCenter():
		return (SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)

</document_content>
</document>
<document index="7">
<source>.\scripts\game_ui.py</source>
<document_content>
import pygame
from scripts import game_screen
from pygame.locals import *

RED = (255, 0, 0)
HEALTH_BAR_MAX = 190

class GameUI:
    def __init__(self):
        self.portrait = pygame.image.load("images/portrait.png")
        self.health_bar_bg = pygame.image.load("images/health_bar_bg.png")
        self.health_rect = pygame.Rect(110, 7, 190, 30)
        self.font = pygame.font.SysFont(None, 24)

    def draw(self, health_coef, player_pos):
        game_screen.Screen.screen.blit(self.portrait, [0, 0])
        game_screen.Screen.screen.blit(self.health_bar_bg, [105, 0])
        self.health_rect.width = HEALTH_BAR_MAX * health_coef
        pygame.draw.rect(game_screen.Screen.screen, RED, self.health_rect)

        dbg_coords = str(player_pos[0]) + " , " + str(player_pos[1])

        coord_text_img = self.font.render(dbg_coords, True, Color('gray'))
        game_screen.Screen.screen.blit(coord_text_img, (10, 110))

    


</document_content>
</document>
<document index="8">
<source>.\scripts\input_manager.py</source>
<document_content>
import pygame
from pygame.locals import *

class InputManager:
    """
    isUpPressed = False
    isDownPressed = False
    isLeftPressed = False
    isRightPressed = False
	"""
    isNeedExit = False

    onKeyDownListeners = []
    onKeyUpListeners = []

    def processEvents():
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                InputManager.isNeedExit = True
                return
            elif event.type == pygame.KEYDOWN:
                for it in InputManager.onKeyDownListeners:
                    it.onKeyDown(event.key)
                """   
                if event.key == pygame.K_LEFT:
                    InputManager.isLeftPressed = True
                elif event.key == pygame.K_RIGHT:
                    InputManager.isRightPressed = True
                elif event.key == pygame.K_UP:
                    InputManager.isUpPressed = True
                elif event.key == pygame.K_DOWN:
                    InputManager.isDownPressed = True
                """
            elif event.type == pygame.KEYUP:
                """
                if event.key == pygame.K_LEFT:
                    InputManager.isLeftPressed = False
                elif event.key == pygame.K_RIGHT:
                    InputManager.isRightPressed = False
                elif event.key == pygame.K_UP:
                    InputManager.isUpPressed = False
                elif event.key == pygame.K_DOWN:
                    InputManager.isDownPressed = False
                """
                for it in InputManager.onKeyUpListeners:
                    it.onKeyUp(event.key)

    def AddKeyDownListener(listener):
    	InputManager.onKeyDownListeners.append(listener)

    def AddKeyUpListener(listener):
    	InputManager.onKeyUpListeners.append(listener)
</document_content>
</document>
<document index="9">
<source>.\scripts\level_generator.py</source>
<document_content>
import numpy as np
import random

class LevelGenerator:
	def __init__(self):
	 	{}

	def GetLevelData(self):
		s = (10, 10)
		#level = np.full(self.size, fill_value = -1, dtype = int)
		#level = np.random.randint(2, size = s)
		level = np.full(s, fill_value = -1, dtype = int)

		# --- 1 room -----------------------------------------
		# --- top
		for x in range(0, 10):
			level[x, 0] = random.randrange(17, 20)

		for x in range(0, 10):
			level[x, 1] = random.randrange(21, 24)
		
		level[0, 0] = 16
		level[0, 1] = 20

		#--- walkable place
		for x in range(0, 10):
			level[x, 9] = random.randrange(13, 15)

		for x in range(0, 10):
			for y in range(3, 9):
				level[x, y] = random.randrange(5, 9)

		#--- break
		for x in range(0, 10):
			level[x, 9] = random.randrange(13, 15)

		return level
</document_content>
</document>
<document index="10">
<source>.\scripts\level_view.py</source>
<document_content>
import pygame
import numpy as np
from scripts import map_data
from scripts import level_generator
from scripts import game_screen
import math
import random

class Tileset:
    def __init__(self, map_info):
        self.file = map_info.image_file
        self.size = (map_info.tile_width, map_info.tile_height)
        self.margin = map_info.margin
        self.spacing = map_info.spacing
        self.image = pygame.image.load(map_info.image_file)
        self.rect = self.image.get_rect()
        self.tiles = []
        self.load()

    def load(self):
        self.tiles = []
        x0 = y0 = self.margin
        w, h = self.rect.size
        dx = self.size[0] + self.spacing
        dy = self.size[1] + self.spacing
        
        for y in range(y0, h, dy):
            for x in range(x0, w, dx):
                #tile = pygame.Surface(self.size)
                tile = pygame.Surface(self.size, pygame.SRCALPHA, 32)
                tile.blit(self.image, (0, 0), (x, y, *self.size))
                self.tiles.append(tile)

    def __str__(self):
        return f'{self.__class__.__name__} file:{self.file} tile:{self.size}'

class Tilemap:
    def __init__(self, tileset, map_info, level_generator = None): 
        self.size = (map_info.width, map_info.height)
        self.tileset = tileset
        self.tile_width = map_info.tile_width
        self.tile_height = map_info.tile_height
        self.map = np.full(self.size, fill_value = -1, dtype = int)
        self.passable = map_info.passable
        self.decor = map_info.decor
        self.objects = map_info.objects

        if level_generator:
            self.map = level_generator.GetLevelData()
        else:
            #print("---> shape:", len(map_info.tiles1), " ", len(map_info.tiles1[0]), " ", map_info.tiles1[0][0])
            for i in range(map_info.width):
                for j in range(map_info.height):
                    self.map[j, i] = map_info.tiles1[i][j]

        h, w = self.size
        #self.image = pygame.Surface((map_info.tile_width * w, map_info.tile_height * h)) #, pygame.SRCALPHA, 32)
        self.image = pygame.Surface((map_info.tile_width * w, map_info.tile_height * h), pygame.SRCALPHA, 32)
        #self.image = self.image.convert_alpha()
        self.rect = self.image.get_rect()
        self.render()

    def render(self):
        m, n = self.map.shape
        #print("--->shape : ", n, " ", m)
        for i in range(m):
            for j in range(n):
                tile_index = self.map[i, j]
                if(tile_index >= 0):
                    #print("---> tileset: ", len(self.tileset.tiles), " i:", self.map[i, j])
                    tile = self.tileset.tiles[self.map[i, j]]
                    self.image.blit(tile, (i * self.tile_width, j * self.tile_height))

        for decor in self.decor:
            x = decor['x']
            y = decor['y']
            tile = self.tileset.tiles[decor["tile"]]
            self.image.blit(tile, (x * self.tile_width, y * self.tile_height))

        for obj in self.objects:
            x = obj['x']
            y = obj['y']
            tile = self.tileset.tiles[obj["tile"]]
            self.image.blit(tile, (x * self.tile_width, y * self.tile_height))
            self.map[x, y] = 1000 # --- to avoid passable here

    def __str__(self):
        return f'{self.__class__.__name__} {self.size}'

class LevelView:
    def __init__(self, map_filename, level_generator = None):
        mapData = map_data.MapData(map_filename)
        tileset = Tileset(mapData)
        self.tilemap = Tilemap(tileset, mapData, level_generator)
        self.pos_x = 0
        self.pos_y = 0

    def draw(self):
        self.tilemap.rect.x = self.pos_x
        self.tilemap.rect.y = self.pos_y
        game_screen.Screen.screen.blit(self.tilemap.image, self.tilemap.rect)

    def SetPosition(self, x, y):
        self.pos_x = x
        self.pos_y = y

    def move(self, dx, dy):
        self.pos_x += dx
        self.pos_y += dy

    def GetPosition(self):
        return (self.pos_x, self.pos_y)

    def getTileSize(self):
        return (self.tilemap.tile_width, self.tilemap.tile_height)

    def isPassable(self, x, y):
        cell_x, cell_y = self.getCellByCoord(x, y)
        w, h = self.tilemap.map.shape
        if cell_x < 0 or cell_y < 0 or cell_x >= w or cell_y >= h: return False
        return self.tilemap.map[cell_x, cell_y] in self.tilemap.passable

    def getCellByCoord(self, x, y):
        cell_x = math.floor(x / self.tilemap.tile_width)
        cell_y = math.floor(y / self.tilemap.tile_height)
        return (cell_x, cell_y)  

    def getCellCoordinates(self, cell_x, cell_y):
        x = cell_x * self.tilemap.tile_width + self.tilemap.tile_width / 2
        y = cell_y * self.tilemap.tile_height + self.tilemap.tile_height / 2
        return (x, y)

    def getRandomPassableCoord(self):
        m, n = self.tilemap.map.shape
        results = []
        for i in range(m):
            for j in range(n):
                if self.tilemap.map[i, j] in self.tilemap.passable:
                    results.append((i, j))

        result_x, result_y = random.choice(results)
        return self.getCellCoordinates(result_x, result_y)

    def reloadMap(self, map_filename):
        mapData = map_data.MapData(map_filename)
        tileset = Tileset(mapData)
        self.tilemap = Tilemap(tileset, mapData, None)
        
</document_content>
</document>
<document index="11">
<source>.\scripts\map_data.py</source>
<document_content>
import json

class MapData:
    def __init__(self, filename):
    	self.load(filename)

    def load(self, filename):
        f = open(filename)
        data = json.load(f)
        self.width = data["width"]
        self.height = data["height"]
        self.tile_width = data["source"]['tile_width']
        self.tile_height = data["source"]['tile_height']
        self.verticals = data["source"]['verticals']
        self.horizontals = data["source"]['horizontals']
        self.image_file = data["source"]['image']
        self.margin = data["source"]['margin']
        self.spacing = data["source"]['spacing']

        self.tiles = data['tiles']
        self.tiles1 = data['tiles1']
        self.passable = data['passable']
        self.decor = data['decor']
        self.objects = data['objects']
</document_content>
</document>
<document index="12">
<source>.\scripts\monster_behaviour.py</source>
<document_content>
from scripts import resource_manager
from pygame.locals import *
from enum import Enum
import math
import pygame
from scripts import my_utils
import random

class PlayerState(Enum):
    IDLE = 1
    WALK = 2
    ATTACK = 3
    DMG = 4
    DIE = 5

class EIntentions(Enum):
    NONE = 0
    GOTO_POINT = 1
    GOTO_PLAYER = 2

class MonsterBehaviour:
    def __init__(self, data_provider, init_x, init_y, uid):
        self.view = None
        self.data_provider = data_provider
        self.uid = uid

        self.pos_x = init_x
        self.pos_y = init_y

        self.state = PlayerState.IDLE

        self.want_attack = False

        self.footprint_width = 10
        self.footprint_height = 8
        self.speed = 2
        self.attackDist = 55
        self.damage = 1
        self.max_health = 100
        self.health = self.max_health

        self.currentIntention = EIntentions.NONE
        self.intentionTimer = pygame.time.get_ticks()
        self.intentionDuration = 1000
        self.intentionPoint = (0, 0)

        self.defaultanimationName = ""

    def Update(self):
        if (self.state == PlayerState.DMG or self.state == PlayerState.DIE):
            return

        if self.want_attack:
            if (self.state == PlayerState.IDLE or self.state == PlayerState.WALK):
                self.setState(PlayerState.ATTACK)
                self.want_attack = False
                self.checkFlip(self.data_provider.getPlayerPosition()[0] - (self.pos_x, self.pos_y)[0])
    
        if (self.state == PlayerState.IDLE or self.state == PlayerState.WALK):
            self.processIntentions()

        my_pos = pygame.Vector2(self.pos_x, self.pos_y)
        player_pos = self.data_provider.getPlayerPosition()
        disToPlayer = (player_pos - my_pos).length() 
        if disToPlayer <= self.attackDist:
            self.want_attack = True

    def assignView(self, view):
        self.view = view
        self.view.SetAnimation(resource_manager.ResourceManager.getAnimation(self.defaultanimationName))

    def setState(self, new_state):
        if not self.view: return
        if (new_state == self.state): return
        self.state = new_state
        self.setAnimation()

    def setAnimation(self):
        pass

    def GetPosition(self):
        return (self.pos_x, self.pos_y)

    def onAnimationComplete(self, name):
        if (name == "attack"):
            self.data_provider.onAttack(self.uid, self.damage)
            self.setState(PlayerState.IDLE)
        elif (name == "damaged"):
            self.setState(PlayerState.IDLE)
        elif (name == "die"):
            self.view.running = False
            self.data_provider.onDie(self.uid)

        #self.want_attack = True #--- for test

    def onDamage(self, damage_count):
        self.health -= damage_count
        if (self.health <= 0):
            self.health = 0
            self.setState(PlayerState.DIE)
        else:
            self.setState(PlayerState.DMG)

    def processIntentions(self):
        if self.currentIntention == EIntentions.NONE:
            pass
        elif self.currentIntention == EIntentions.GOTO_PLAYER:
            player_pos = pygame.Vector2(self.data_provider.getPlayerPosition())
            target_pos = my_utils.getRandomPointNear(player_pos, 100)  # --- change 100 to some look distance
            self.processMoving(target_pos)
        elif self.currentIntention == EIntentions.GOTO_POINT:
            self.processMoving(self.intentionPoint)
        # --- switch enemy intension pereodicaly ---
        if pygame.time.get_ticks() - self.intentionTimer > self.intentionDuration:
            self.intentionTimer = pygame.time.get_ticks()
            self.switchIntention()

    def switchIntention(self):
        if self.isPlayerNear():
            self.currentIntention = random.choice(list(EIntentions))    
        else:
            self.currentIntention = random.choice([EIntentions.NONE, EIntentions.GOTO_POINT])

        self.intentionTimer = pygame.time.get_ticks()
        if self.currentIntention == EIntentions.GOTO_POINT:
             self.intentionPoint = self.data_provider.getRandomPassablePoint()
        elif self.currentIntention == EIntentions.NONE:
            self.setState(PlayerState.IDLE)
        #print("---> new int is: ", self.currentIntention)
    
    def processMoving(self, target_pos):
        my_pos = pygame.Vector2(self.pos_x, self.pos_y)
        
        dir = target_pos - my_pos
        
        if dir.length() > self.speed * 1.5:
            dx, dy = dir.normalize() *  self.speed
            new_x = self.pos_x + dx
            new_y = self.pos_y + dy
            isValid = self.data_provider.canMoveHere(new_x, new_y, self.footprint_width, self.footprint_height)
            if (isValid):
                self.pos_x = new_x
                self.pos_y = new_y
            if (math.fabs(dx) > 0 or math.fabs(dy) > 0):
                self.setState(PlayerState.WALK)
            else:
                self.setState(PlayerState.IDLE)
            if (self.view):
                if math.fabs(dir[0]) > 60:  #--- dont need flip if dx so small to avoid vibration
                    self.checkFlip(dx)
        else:
            if self.currentIntention == EIntentions.GOTO_POINT:
                self.switchIntention()

    def checkFlip(self, dx):
        if (dx < 0):
            self.view.SetFlip(True) 
        elif (dx > 0): 
            self.view.SetFlip(False)

    def isPlayerNear(self):
        player_pos = pygame.Vector2(self.data_provider.getPlayerPosition())
        my_pos = pygame.Vector2(self.pos_x, self.pos_y)
        return (player_pos - my_pos).length() < 360
</document_content>
</document>
<document index="13">
<source>.\scripts\my_utils.py</source>
<document_content>
from scripts import actor
import math
import random

def distBetweenActors(actor1, actor2):
    return math.dist(actor1.getPosition(), actor2.getPosition()) 

def isActor1LookAtActor2(actor1, actor2):
    x1, y1 = actor1.getPosition()
    x2, y2 = actor2.getPosition()
    if actor1.isRightDierction():
        return x2 >= x1
    else:
        return x2 <= x1

def getRandomPointNear(point, delta):
    x, y = point
    dx = x + random.randrange(delta) - delta / 2
    dy = y + random.randrange(delta) - delta / 2
    return (dx, dy)
</document_content>
</document>
<document index="14">
<source>.\scripts\player_controller.py</source>
<document_content>
from scripts import resource_manager
from pygame.locals import *
from enum import Enum
import math

class PlayerState(Enum):
    IDLE = 1
    WALK = 2
    ATTACK = 3
    DMG = 4
    DIE = 5

class PlayerController:
    def __init__(self, data_provider, uid):
        self.view = None
        self.data_provider = data_provider
        self.uid = uid

        self.want_up = False
        self.want_down = False
        self.want_left = False
        self.want_right = False
        self.want_attack = False

        init_x, init_y = data_provider.getPlayerInitialPos()
        self.pos_x = init_x
        self.pos_y = init_y

        self.state = PlayerState.IDLE

        self.footprint_width = 20
        self.footprint_height = 10
        self.speed = 2 #<---- get from config ??!!
        self.attackDist = 60
        self.damage = 50

        self.max_health = 100
        self.health = self.max_health

    def Update(self):
        if (self.state == PlayerState.DMG or self.state == PlayerState.DIE):
            return

        if self.want_attack:
        	if (self.state == PlayerState.IDLE or self.state == PlayerState.WALK):
        		self.setState(PlayerState.ATTACK)
        		self.want_attack = False
    
        if (self.state == PlayerState.IDLE or self.state == PlayerState.WALK):
            dx = 0
            dy = 0
            if self.want_up: dy -= self.speed
            if self.want_down: dy += self.speed
            if self.want_right: dx += self.speed
            if self.want_left: dx -= self.speed

            new_x = self.pos_x + dx
            new_y = self.pos_y + dy

            isValid = self.data_provider.canMoveHere(new_x, new_y, self.footprint_width, self.footprint_height)

            if (isValid):
                self.pos_x = new_x
                self.pos_y = new_y
                self.data_provider.onPlayerMove(dx, dy)

            if (math.fabs(dx) > 0 or math.fabs(dy) > 0):
                self.setState(PlayerState.WALK)
            else:
                self.setState(PlayerState.IDLE)

            if (self.view):
                if (dx < 0):
                    self.view.SetFlip(True) 
                elif (dx > 0): 
                    self.view.SetFlip(False)
            

    def onKeyDown(self, ley_id):
        if ley_id == K_d: self.want_right = True
        elif ley_id == K_a: self.want_left = True
        elif ley_id == K_w: self.want_up = True
        elif ley_id == K_s: self.want_down = True
        elif ley_id == K_SPACE: self.want_attack = True

    def onKeyUp(self, ley_id):
        if ley_id == K_d: self.want_right = False
        elif ley_id == K_a: self.want_left = False
        elif ley_id == K_w: self.want_up = False
        elif ley_id == K_s: self.want_down = False

    def assignView(self, view):
        self.view = view
        self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/paladin_idle.json"))

    def setState(self, new_state):
        if not self.view: return
        if (new_state == self.state): return

        if (new_state == PlayerState.IDLE):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/paladin_idle.json"))
        elif (new_state == PlayerState.WALK):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/paladin_walk.json"))
        elif (new_state == PlayerState.ATTACK):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/paladin_attack.json"))
        elif (new_state == PlayerState.DIE):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/paladin_die.json"))
        elif (new_state == PlayerState.DMG):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/paladin_damaged.json"))

        self.state = new_state

    def GetPosition(self):
    	return (self.pos_x, self.pos_y)

    def onAnimationComplete(self, name):
        if (name == "attack"):
            self.data_provider.onAttack(self.uid, self.damage)
            self.setState(PlayerState.IDLE)
        elif (name == "damaged"):
            self.setState(PlayerState.IDLE)
        elif (name == "die"):
            self.view.running = False
            self.view.setLastFrame()
            #self.data_provider.onDie(self.uid)

    def onDamage(self, damage_count):
        self.health -= damage_count
        if (self.health <= 0):
            self.health = 0
            self.setState(PlayerState.DIE)
        else:
            if (self.state == PlayerState.IDLE or self.state == PlayerState.WALK):
                self.setState(PlayerState.DMG)




</document_content>
</document>
<document index="15">
<source>.\scripts\resource_manager.py</source>
<document_content>
import pygame
from scripts import animation
from scripts import sprite_sheet

class ResourceManager:
    images = dict()
    animations = dict()    
    
    @staticmethod    
    def getImage(image_name):
    	if image_name in ResourceManager.images.keys():
    		return ResourceManager.images[image_name]
    	else:
    		ResourceManager.images[image_name] = pygame.image.load(image_name)
    		return ResourceManager.images[image_name]

    @staticmethod    
    def getAnimation(animation_name):
        if animation_name in ResourceManager.animations.keys():
            return ResourceManager.animations[animation_name]
        else:
            anim_data = animation.AnimationData(animation_name)

            sheet = sprite_sheet.SpriteSheet(anim_data.image_file, anim_data.width, anim_data.height)
            sprites = []
            for frame in anim_data.frames:
                sprites.append(sheet.image_frame(frame))
            
            anim = animation.Animation(sprites, anim_data)

            ResourceManager.animations[animation_name] = anim
            
            return ResourceManager.animations[animation_name]

</document_content>
</document>
<document index="16">
<source>.\scripts\skeleton_logic.py</source>
<document_content>
from scripts import monster_behaviour
from scripts import resource_manager

class SkeletonLogic(monster_behaviour.MonsterBehaviour):
    def __init__(self, data_provider, init_x, init_y, uid):
        monster_behaviour.MonsterBehaviour.__init__(self, data_provider, init_x, init_y, uid)
        self.defaultanimationName = "data/skeleton_idle.json"
        self.damage = 10

    def setAnimation(self):
        if (self.state == monster_behaviour.PlayerState.IDLE):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/skeleton_idle.json"))
        elif (self.state == monster_behaviour.PlayerState.WALK):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/skeleton_walk.json"))
        elif (self.state == monster_behaviour.PlayerState.ATTACK):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/skeleton_attack.json"))
        elif (self.state == monster_behaviour.PlayerState.DIE):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/skeleton_die.json"))
        elif (self.state == monster_behaviour.PlayerState.DMG):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/skeleton_damaged.json"))

</document_content>
</document>
<document index="17">
<source>.\scripts\sprite_sheet.py</source>
<document_content>
import pygame
from scripts import resource_manager 

class SpriteSheet(object):
    def __init__(self, fileName, piece_width, piece_height, offset_x = 0, offset_y = 0):
        self.sheet = resource_manager.ResourceManager.getImage(fileName)
        self.piece_width = piece_width
        self.piece_height = piece_height
        self.offset_x = offset_x
        self.offset_y = offset_y

    def image_frame(self, frame):
    	x_coord = frame['x'] - self.piece_width / 2
    	y_coord = frame['y'] - self.piece_height
    	rectangle = (x_coord, y_coord, self.piece_width, self.piece_height)
    	rect = pygame.Rect(rectangle)
    	image = pygame.Surface(rect.size, pygame.SRCALPHA, 32).convert_alpha()
    	image.blit(self.sheet, (0, 0), rect)
    	return image  
</document_content>
</document>
<document index="18">
<source>.\scripts\zombie_logic.py</source>
<document_content>
from scripts import monster_behaviour
from scripts import resource_manager

class ZombieLogic(monster_behaviour.MonsterBehaviour):
    def __init__(self, data_provider, init_x, init_y, uid):
        monster_behaviour.MonsterBehaviour.__init__(self, data_provider, init_x, init_y, uid)
        self.defaultanimationName = "data/zombie_idle.json"
        self.speed = 1
        self.damage = 15

    def setAnimation(self):
        if (self.state == monster_behaviour.PlayerState.IDLE):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/zombie_idle.json"))
        elif (self.state == monster_behaviour.PlayerState.WALK):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/zombie_walk.json"))
        elif (self.state == monster_behaviour.PlayerState.ATTACK):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/zombie_attack.json"))
        elif (self.state == monster_behaviour.PlayerState.DIE):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/zombie_die.json"))
        elif (self.state == monster_behaviour.PlayerState.DMG):
            self.view.SetAnimation(resource_manager.ResourceManager.getAnimation("data/zombie_damaged.json"))

</document_content>
</document>
</documents>
